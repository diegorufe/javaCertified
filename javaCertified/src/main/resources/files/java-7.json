{
	"questions" : [
			{
				"text" : "Consider the following program:\r\n\r\nclass StrEqual {\r\n\r\n\tpublic static void main(String []args) {\r\n\t\tString s1 = \"hi\";\r\n\t\tString s2 = new String(\"hi\");\r\n\t\tString s3 = \"hi\";\r\n\t \r\n\t\tif(s1 == s2) {\r\n\t\t\tSystem.out.println(\"s1 and s2 equal\");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(\"s1 and s2 not equal\");\r\n\t\t}\r\n\t \r\n\t\tif(s1 == s3) {\r\n\t\tSystem.out.println(\"s1 and and s3 equal\");\r\n\t\t} else {\r\n\t\t\tSystem.out.println(\"s1 and and s3 not equal\");\r\n\t\t}\r\n\t}\r\n}\r\n",
				"answers" :[
					{
						"text": "s1 and s2 equal\r\ns1 and s3 equal",
						"index": 1
					},
					{
						"text": "s1 and s2 equal\r\ns1 and s3 not equal",
						"index": 2
					},
					{
						"text": "s1 and s2 not equal\r\ns1 and s3 equal",
						"index": 3
					},
					{
						"text": "s1 and s2 not equal\r\ns1 and s3 not equal",
						"index": 4
					}
				],
				"indexSuccesQuestion" : 3,
				"explanation": "JVM sets a constant pool in which it stores all the string constants used in the type. If two references are\r\ndeclared with a constant, then both refer to the same constant object. The == operator checks the similarity of\r\nobjects itself (and not the values in it). Here, the first comparison is between two distinct objects, so we get s1\r\nand s2 not equal. On the other hand, since references of s1 and s3 refer to the same object, we get s1 and\r\ns3 equal."
			},
			{
				"text" : "Consider the following program:\r\n\tclass Point2D {\r\n\t\tprivate int x, y;\r\n\t\tpublic Point2D(int x, int y) {\r\n\t\t\tx = x;\r\n\t\t}\r\n\t \r\n\t\tpublic String toString() {\r\n\t\t\treturn \"[\" + x + \", \" + y + \"]\";\r\n\t\t}\r\n\t\tpublic static void main(String []args) {\r\n\t\t\tPoint2D point = new Point2D(10, 20);\r\n\t\t\tSystem.out.println(point);\r\n\t\t}\r\n}",
				"answers" :[
					{
						"text": "point",
						"index": 1
					},
					{
						"text": "Point",
						"index": 2
					},
					{
						"text": "[0, 0]",
						"index": 3
					},
					{
						"text": "[10, 0]",
						"index": 4
					},
					{
						"text": "[10, 20]",
						"index": 5
					}
				],
				"indexSuccesQuestion" : 3,
				"explanation" : "The assignment x = x; inside the construct reassigns the passed parameter; it does not assign the member\r\nx in Point2D. The correct way to perform the assignment is this.x = x;. Field y is not assigned, so its value\r\nremains 0."
			},
			{
				"text": "class Increment {\r\npublic static void main(String []args) {\r\nInteger i = 10;\r\nInteger j = 11;\r\nInteger k = ++i;\r\n\/\/ INCR\r\nSystem.out.println(\"k == j is \" + (k == j));\r\nSystem.out.println(\"k.equals(j) is \" + k.equals(j));\r\n}\r\n}",
				"answers" :[
					{
						"text": "When executed, this program prints\r\nk == j is false\r\nk.equals(j) is false",
						"index": 1
					},
					{
						"text": "When executed, this program prints\r\nk == j is true\r\nk.equals(j) is false",
						"index": 2
					},
					{
						"text": "When executed, this program prints\r\nk == j is false\r\nk.equals(j) is true",
						"index": 3
					},
					{
						"text": "When executed, this program prints\r\nk == j is true\r\nk.equals(j) is true",
						"index": 4
					},
					{
						"text": "When compiled, the program will result in a compiler error in the line marked with the comment INCR",
						"index": 5
					}
				],
				"indexSuccesQuestion" : 4,
				"explanation": "The Integer objects are immutable objects. If there is an Integer object for a value that already exists, then\r\nit does not create a new object again. In other words, Java uses sharing of immutable Integer objects, so two\r\nInteger objects are equal if their values are equal (no matter if you use == operators to compare the references or\r\nuse equals() method to compare the contents)."
			},
			{
				"text" : "Consider the following program:\r\nclass ArrayCompare {\r\n\tpublic static void main(String []args) {\r\n\t\tint []arr1 = {1, 2, 3, 4, 5};\r\n\t\tint []arr2 = {1, 2, 3, 4, 5};\r\n\t\tSystem.out.println(\"arr1 == arr2 is \" + (arr1 == arr2));\r\n\t\tSystem.out.println(\"arr1.equals(arr2) is \" + arr1.equals(arr2));\r\n\t\tSystem.out.println(\"Arrays.equals(arr1, arr2) is \" +\r\n\t\tjava.util.Arrays.equals(arr1, arr2));\r\n\t}\r\n}",
				"answers" :[
					{
						"text": "arr1 == arr2 is false\r\narr1.equals(arr2) is false\r\nArrays.equals(arr1, arr2) is true",
						"index": 1
					},
					{
						"text": "arr1 == arr2 is true\r\narr1.equals(arr2) is false\r\nArrays.equals(arr1, arr2) is true",
						"index": 2
					},
					{
						"text": "arr1 == arr2 is false\r\narr1.equals(arr2) is true\r\nArrays.equals(arr1, arr2) is true",
						"index": 3
					},
					{
						"text": "arr1 == arr2 is true\r\narr1.equals(arr2) is true\r\nArrays.equals(arr1, arr2) is false",
						"index": 4
					},
					{
						"text": "arr1 == arr2 is true\r\narr1.equals(arr2) is true\r\nArrays.equals(arr1, arr2) is true",
						"index": 5
					}
				],
				"indexSuccesQuestion" : 1,
				"explanation" : "The first comparison between two array objects is carried out using the == operator, which compares object\r\nsimilarity so it returns false here. The equals() method, which compares this array object with the passed array\r\nobject, does not compare values of the array since it is inherited from the Object class. Thus we get another false.\r\nOn the other hand, the Arrays class implements various equals() methods to compare two array objects of\r\ndifferent types; hence we get true from the last invocation."
			},
			{
				"text": "Consider the following program:\r\nclass NullInstanceof {\r\n\tpublic static void main(String []args){\r\n\t\tString str = null;\r\n\t\tif(str instanceof Object){\t \/\/ NULLCHK\r\n\t\t\tSystem.out.println(\"str is Object\");\r\n\t\t}else{\r\n\t\t\tSystem.out.println(\"str is not Object\");\r\n\t\t}\r\n\t}\r\n}",
				"answers" :[
					{
						"text": "This program will result in a compiler error in line marked with comment NULLCHK.",
						"index": 1
					},
					{
						"text": "This program will result in a NullPointerException in line marked with comment NULLCHK",
						"index": 2
					},
					{
						"text": "When executed, this program will print the following: str is Object",
						"index": 3
					},
					{
						"text": "When executed, this program will print the following: str is not Object",
						"index": 4
					}
				],
				"indexSuccesQuestion" : 4,
				"explanation" : "The variable str was declared but not instantiated; hence the instanceof operator returns false."
			},
			{
				"text": "interface Side { String getSide(); }\r\n \r\nclass Head implements Side {\r\n\tpublic String getSide() { return \"Head \"; }\r\n}\r\n \r\nclass Tail implements Side {\r\n\tString getSide() { return \"Tail \"; }\r\n}\r\n\r\nclass Coin {\r\n public static void overload(Head side) { System.out.print(side.getSide()); }\r\n public static void overload(Tail side) { System.out.print(side.getSide()); }\r\n public static void overload(Side side) { System.out.print(\"Side \"); }\r\n public static void overload(Object side) { System.out.print(\"Object \"); }\r\n\r\n public static void main(String []args) {\r\n Side firstAttempt = new Head();\r\n Tail secondAttempt = new Tail();\r\n overload(firstAttempt);\r\n overload((Object)firstAttempt);\r\n overload(secondAttempt);\r\n overload((Side)secondAttempt);\r\n }\r\n}",
				"answers" :[
					{
						"text": "Head Head Tail Tail",
						"index": 1
					},
					{
						"text": "Side Object Tail Side",
						"index": 2
					},
					{
						"text": "Head Object Tail Side",
						"index": 3
					},
					{
						"text": "Side Head Tail Side",
						"index": 4
					}
				],
				"indexSuccesQuestion" : 2,
				"explanation" : "Overloading is based on the static type of the objects (while overriding and runtime resolution resolves to the\r\ndynamic type of the objects). Here is how the calls to the overload() method are resolved:\r\n\r\n\u2022\t overload(firstAttempt); --> firstAttempt is of type Side, hence it resolves to\r\noverload(Side).\r\n\u2022\t overload((Object)firstAttempt); -> firstAttempt is casted to Object, hence it resolves to\r\noverload(Object)."
			},
			{
				"text": "Consider the following program:\r\nclass Overloaded {\r\n public static void foo(Integer i) { System.out.println(\"foo(Integer)\"); }\r\n public static void foo(short i) { System.out.println(\"foo(short)\"); }\r\n public static void foo(long i) { System.out.println(\"foo(long)\"); }\r\n public static void foo(int ... i) { System.out.println(\"foo(int ...)\"); }\r\n public static void main(String []args) {\r\n foo(10);\r\n }\r\n}",
				"answers" :[
					{
						"text": "foo(Integer)",
						"index": 1
					},
					{
						"text": "foo(short)",
						"index": 2
					},
					{
						"text": "foo(long)",
						"index": 3
					},
					{
						"text": "foo(int ...)",
						"index": 4
					}
				],
				"indexSuccesQuestion" : 3,
				"explanation" : "For an integer literal, the JVM matches in the following order: int, long, Integer, int.... In other words, it\r\nfirst looks for an int type parameter; if it is not provided, then it looks for long type; and so on. Here, since the int\r\ntype parameter is not specified with any overloaded method, it matches with foo(long)."
			},
			{
				"text": "Consider the following program:\r\nclass Base {\r\n public static void foo(Base bObj) {\r\n System.out.println(\"In Base.foo()\");\r\n bObj.bar();\r\n }\r\n \r\n public void bar() {\r\n System.out.println(\"In Base.bar()\");\r\n }\r\n}\r\nclass Derived extends Base {\r\n public static void foo(Base bObj) {\r\n System.out.println(\"In Derived.foo()\");\r\n bObj.bar();\r\n }\r\n public void bar() {\r\n System.out.println(\"In Derived.bar()\");\r\n }\r\n}\r\nclass OverrideTest {\r\n public static void main(String []args) {\r\n Base bObj = new Derived();\r\n bObj.foo(bObj);\r\n }\r\n}",
				"answers" :[
					{
						"text": "In Base.foo() In Base.bar()",
						"index": 1
					},
					{
						"text": "In Base.foo() In Derived.bar()",
						"index": 2
					},
					{
						"text": "In Derived.foo() In Base.bar()",
						"index": 3
					},
					{
						"text": "In Derived.foo() In Derived.bar()",
						"index": 4
					}
				],
				"indexSuccesQuestion" : 2,
				"explanation" : "A static method is resolved statically. Inside the static method, a virtual method is invoked, which is resolved\r\ndynamically."
			},
			{
				"text": "class CannotFlyException extends Exception {}\r\ninterface Birdie {\r\n public abstract void fly() throws CannotFlyException;\r\n}\r\ninterface Biped {\r\n public void walk();\r\n}\r\nabstract class NonFlyer {\r\n public void fly() { System.out.print(\"cannot fly \"); } \/\/ LINE A\r\n}\r\n\r\nclass Penguin extends NonFlyer implements Birdie, Biped { \/\/ LINE B\r\n public void walk() { System.out.print(\"walk \"); }\r\n}\r\nclass PenguinTest {\r\n public static void main(String []args) {\r\n Penguin pingu = new Penguin();\r\n pingu.walk();\r\n pingu.fly();\r\n }\r\n}",
				"answers" :[
					{
						"text": "Compiler error in line with comment LINE A because fly() does not declare to throw CannotFlyException.",
						"index": 1
					},
					{
						"text": "Compiler error in line with comment LINE B because fly() is not defined and hence need to declare it abstract.",
						"index": 2
					},
					{
						"text": "It crashes after throwing the exception CannotFlyException.",
						"index": 3
					},
					{
						"text": "When executed, the program prints â€œwalk cannot fly",
						"index": 4
					}
				],
				"indexSuccesQuestion" : 4,
				"explanation" : "In order to override a method, it is not necessary for the overridden method to specify an exception. However, if\r\nthe exception is specified, then the specified exception must be the same or a subclass of the specified exception\r\nin the method defined in the super class (or interface)."
			},
			{
				"text": "class TestSwitch {\r\n public static void main(String []args) {\r\n String [] cards = { \"Club\", \"spade\", \" diamond \", \"hearts\" };\r\n for(String card : cards) {\r\n switch(card) {\r\n case \"Club\" : System.out.print(\" club \"); break;\r\n case \"Spade\" : System.out.print(\" spade \"); break;\r\n case \"diamond\" : System.out.print(\" diamond \"); break;\r\n case \"heart\" : System.out.print(\" heart \"); break;\r\n default: System.out.print(\" none \");\r\n }\r\n }\r\n }\r\n}",
				"answers" :[
					{
						"text": "none none none none",
						"index": 1
					},
					{
						"text": "club none none none",
						"index": 2
					},
					{
						"text": "club spade none none",
						"index": 3
					},
					{
						"text": "club spade diamond none",
						"index": 4
					},
					{
						"text": "club spade diamond heart",
						"index": 5
					}
				],
				"indexSuccesQuestion" : 2,
				"explanation" : "Here is the description of matches for the four enumeration values:\r\n\u2022\t \u201Cclub\u201D matches with the case \u201CClub\u201D.\r\n\u2022\t For \u201CSpade\u201D, the case \u201Cspade\u201D does not match because of the case difference (switch case\r\nmatch is case sensitive).\r\n\u2022\t does not match with \u201Cdiamond\u201D because case statements should exactly match and there are\r\nextra whitespaces in the original string.\r\n\u2022\t \u201Chearts\u201D does not match the string \u201Cheart\u201D."
			}
		]
}